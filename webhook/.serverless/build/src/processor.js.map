{
  "version": 3,
  "sources": ["../../../src/processor.ts", "../../../src/aws-local.ts", "../../../src/libs/events.ts"],
  "sourcesContent": ["import type { SQSEvent } from \"aws-lambda\";\r\nimport { DynamoDBClient } from \"@aws-sdk/client-dynamodb\";\r\nimport {\r\n  DynamoDBDocumentClient,\r\n  GetCommand,\r\n  PutCommand,\r\n  UpdateCommand,\r\n} from \"@aws-sdk/lib-dynamodb\";\r\nimport { publishEvent } from \"./libs/events\";\r\nimport { localAwsConfig } from \"./aws-local\";\r\n\r\n// ---------- config\r\nconst ddb = DynamoDBDocumentClient.from(new DynamoDBClient(localAwsConfig()));\r\nconst DRIVER_TABLE = process.env.DRIVER_STATE_TABLE!;\r\nconst ARRIVE_RADIUS_M = parseInt(process.env.ARRIVE_RADIUS_M ?? \"150\", 10);\r\nconst DEPART_EXIT_RADIUS_M = parseInt(process.env.DEPART_EXIT_RADIUS_M ?? \"200\", 10);\r\nconst ARRIVE_MAX_SPEED_KPH = parseInt(process.env.ARRIVE_MAX_SPEED_KPH ?? \"15\", 10);\r\nconst DEPART_MIN_SPEED_KPH = parseInt(process.env.DEPART_MIN_SPEED_KPH ?? \"8\", 10);\r\nconst ARRIVE_DWELL_PINGS = parseInt(process.env.ARRIVE_DWELL_PINGS ?? \"2\", 10);\r\nconst DEPART_DWELL_PINGS = parseInt(process.env.DEPART_DWELL_PINGS ?? \"2\", 10);\r\n\r\n// local simulator API\r\nconst SIM_API = process.env.SIM_API_URL ?? \"http://localhost:4001\";\r\n\r\n// ---------- types (internal)\r\ntype StopType = \"PICKUP\" | \"DELIVERY\";\r\ntype Stop = { id: string; type: StopType; lat: number; lng: number; radiusM?: number; eta?: string };\r\ntype Route = { routeId: string; driverId: string; stops: Stop[]; status: \"PLANNED\" | \"EN_ROUTE\" | \"COMPLETED\" | \"CANCELLED\"; updatedAt?: string };\r\n\r\ntype DriverPhase = \"IDLE\" | \"ENROUTE\" | \"AT_STOP\" | \"COMPLETED\";\r\ntype DriverState = {\r\n  driverId: string;\r\n  routeId?: string;\r\n  currentStopIndex?: number;\r\n  phase: DriverPhase;\r\n  lastLat?: number;\r\n  lastLon?: number;\r\n  lastUpdateAt?: string;\r\n  arrivedAt?: string;\r\n  departedAt?: string;\r\n  insideCount?: number;\r\n  outsideCount?: number;\r\n  version: number;\r\n};\r\n\r\ntype GpsPayload = {\r\n  eventId: string;\r\n  driverId: string;\r\n  deviceTs: string;\r\n  lat: number;\r\n  lng: number;\r\n  speedKph?: number;\r\n};\r\n\r\n// ---------- ddb helpers (driver state only)\r\nconst getDriver = async (driverId: string) =>\r\n  (await ddb.send(new GetCommand({ TableName: DRIVER_TABLE, Key: { driverId } })))?.Item as DriverState | undefined;\r\n\r\nconst putDriver = (state: DriverState) =>\r\n  ddb.send(new PutCommand({ TableName: DRIVER_TABLE, Item: state }));\r\n\r\nasync function updateDriver(driverId: string, updates: Partial<DriverState>) {\r\n  const names: Record<string, string> = { \"#version\": \"version\" };\r\n  const values: Record<string, any> = { \":v0\": 0, \":one\": 1 };\r\n  const sets: string[] = [\"#version = if_not_exists(#version, :v0) + :one\"];\r\n  for (const [k, v] of Object.entries(updates)) {\r\n    names[`#${k}`] = k;\r\n    values[`:${k}`] = v;\r\n    sets.unshift(`#${k} = :${k}`);\r\n  }\r\n  await ddb.send(new UpdateCommand({\r\n    TableName: DRIVER_TABLE,\r\n    Key: { driverId },\r\n    UpdateExpression: `SET ${sets.join(\", \")}`,\r\n    ExpressionAttributeNames: names,\r\n    ExpressionAttributeValues: values,\r\n    ReturnValues: \"ALL_NEW\",\r\n  }));\r\n}\r\n\r\n// ---------- simulator API helpers\r\nasync function fetchJson<T>(url: string): Promise<T | undefined> {\r\n  const res = await fetch(url);\r\n  if (!res.ok) return undefined;\r\n  return res.json() as Promise<T>;\r\n}\r\n\r\n// Simulator shapes\r\ntype SimLatLng = { lat: number; lng: number };\r\ntype SimStop = {\r\n  id: string;\r\n  sequence: number;\r\n  type: \"PICKUP\" | \"DELIVERY\";\r\n  name?: string;\r\n  location: SimLatLng;\r\n  radiusM?: number;\r\n  windowStart?: string;\r\n  windowEnd?: string;\r\n};\r\ntype SimRoute = {\r\n  id: string;\r\n  driverId: string;\r\n  shipmentId: string;\r\n  status: \"PLANNED\" | \"EN_ROUTE\" | \"COMPLETED\" | \"CANCELLED\";\r\n  stops: SimStop[];\r\n  updatedAt?: string;\r\n};\r\ntype SimDriver = { id: string; name: string };\r\n\r\n// Map simulator route \u2192 internal\r\nfunction toInternalRoute(r: SimRoute): Route {\r\n  const stops: Stop[] = (r.stops ?? [])\r\n    .sort((a, b) => a.sequence - b.sequence)\r\n    .map(s => ({\r\n      id: s.id,\r\n      type: s.type,\r\n      lat: s.location.lat,\r\n      lng: s.location.lng,\r\n      radiusM: s.radiusM,\r\n    }));\r\n  return { routeId: r.id, driverId: r.driverId, stops, status: r.status, updatedAt: r.updatedAt };\r\n}\r\n\r\n// Get route by id (try /routes/:id; fallback to /routest/:id if needed)\r\nasync function getRoute(routeId: string): Promise<Route | undefined> {\r\n  const main = await fetchJson<SimRoute>(`${SIM_API}/routes/${routeId}`);\r\n  const sim = main ?? (await fetchJson<SimRoute>(`${SIM_API}/routest/${routeId}`)); // tolerate typo\r\n  return sim ? toInternalRoute(sim) : undefined;\r\n}\r\n\r\n// Find a \u201Ccurrent\u201D route for a driver:\r\n// - prefer EN_ROUTE\r\n// - else PLANNED (earliest by updatedAt if present)\r\n// - ignore COMPLETED/CANCELLED\r\nasync function getCurrentRouteForDriver(driverId: string): Promise<Route | undefined> {\r\n  const simDriver = await fetchJson<SimDriver>(`${SIM_API}/drivers/${driverId}`);\r\n  if (!simDriver) return undefined;\r\n\r\n  const simRoutes = await fetchJson<SimRoute[]>(`${SIM_API}/drivers/${driverId}/routes`);\r\n  if (!simRoutes || simRoutes.length === 0) return undefined;\r\n\r\n  const candidates = simRoutes.filter(r => r.status === \"EN_ROUTE\" || r.status === \"PLANNED\");\r\n  if (candidates.length === 0) return undefined;\r\n\r\n  const pick =\r\n    candidates.find(r => r.status === \"EN_ROUTE\") ??\r\n    candidates\r\n      .filter(r => r.status === \"PLANNED\")\r\n      .sort((a, b) => (a.updatedAt ?? \"\").localeCompare(b.updatedAt ?? \"\"))[0];\r\n\r\n  return pick ? toInternalRoute(pick) : undefined;\r\n}\r\n\r\n// ---------- geo\r\nfunction haversineMeters(a: { lat: number; lon: number }, b: { lat: number; lon: number }) {\r\n  const toRad = (d: number) => (d * Math.PI) / 180;\r\n  const R = 6371e3;\r\n  const dLat = toRad(b.lat - a.lat);\r\n  const dLon = toRad(b.lon - a.lon);\r\n  const lat1 = toRad(a.lat);\r\n  const lat2 = toRad(b.lat);\r\n  const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;\r\n  return 2 * R * Math.asin(Math.sqrt(h));\r\n}\r\nconst insideStopRadius = (stop: Stop, lat: number, lon: number) =>\r\n  haversineMeters({ lat, lon }, { lat: stop.lat, lon: stop.lng }) <= (stop.radiusM ?? ARRIVE_RADIUS_M);\r\n\r\n// ---------- gps handler\r\nasync function handleGps(p: GpsPayload) {\r\n  await publishEvent(\"gps.received\", { eventId: p.eventId, driverId: p.driverId }, \"logistics.ingest\");\r\n\r\n  // ensure driver state exists\r\n  let state = await getDriver(p.driverId);\r\n  if (!state) {\r\n    state = { driverId: p.driverId, phase: \"IDLE\", insideCount: 0, outsideCount: 0, version: 0 };\r\n    await putDriver(state);\r\n  }\r\n\r\n  // save last position\r\n  await updateDriver(p.driverId, { lastLat: p.lat, lastLon: p.lng, lastUpdateAt: p.deviceTs });\r\n  state = { ...state, lastLat: p.lat, lastLon: p.lng, lastUpdateAt: p.deviceTs, version: state.version + 1 };\r\n\r\n  // ensure we have a route in state (lightweight selection)\r\n  let route: Route | undefined;\r\n  if (state.routeId) {\r\n    route = await getRoute(state.routeId);\r\n  } else {\r\n    const current = await getCurrentRouteForDriver(p.driverId);\r\n    if (current) {\r\n      await updateDriver(p.driverId, {\r\n        routeId: current.routeId,\r\n        currentStopIndex: 0,\r\n        phase: \"ENROUTE\",\r\n      });\r\n      state = { ...state, routeId: current.routeId, currentStopIndex: 0, phase: \"ENROUTE\" };\r\n      route = current;\r\n    }\r\n  }\r\n  if (!route || !route.stops?.length || state.currentStopIndex === undefined) return;\r\n\r\n  const idx = Math.min(state.currentStopIndex, route.stops.length - 1);\r\n  const stop = route.stops[idx];\r\n  const speed = p.speedKph ?? 0;\r\n\r\n  const isInside = insideStopRadius(stop, p.lat, p.lng);\r\n  const nextInside = isInside ? (state.insideCount ?? 0) + 1 : 0;\r\n  const nextOutside = isInside ? 0 : (state.outsideCount ?? 0) + 1;\r\n\r\n  await updateDriver(p.driverId, { insideCount: nextInside, outsideCount: nextOutside });\r\n  state = { ...state, insideCount: nextInside, outsideCount: nextOutside, version: state.version + 1 };\r\n\r\n  if (state.phase !== \"AT_STOP\") {\r\n    const arrived = isInside && speed <= ARRIVE_MAX_SPEED_KPH && nextInside >= ARRIVE_DWELL_PINGS;\r\n    if (arrived) {\r\n      await updateDriver(p.driverId, { phase: \"AT_STOP\", arrivedAt: p.deviceTs, outsideCount: 0 });\r\n      state = { ...state, phase: \"AT_STOP\", arrivedAt: p.deviceTs, outsideCount: 0 };\r\n      await publishEvent(\r\n        stop.type === \"PICKUP\" ? \"driver.arrived.pickup\" : \"driver.arrived.delivery\",\r\n        { eventId: p.eventId, driverId: p.driverId, routeId: state.routeId, stopId: stop.id, stopIndex: idx, lat: p.lat, lng: p.lng, occurredAt: p.deviceTs }\r\n      );\r\n    }\r\n  } else {\r\n    const departed = !isInside && speed >= DEPART_MIN_SPEED_KPH && nextOutside >= DEPART_DWELL_PINGS;\r\n    if (departed) {\r\n      const nextIdx = idx + 1;\r\n      const completed = nextIdx >= route.stops.length;\r\n\r\n      await updateDriver(p.driverId, {\r\n        phase: completed ? \"COMPLETED\" : \"ENROUTE\",\r\n        departedAt: p.deviceTs,\r\n        currentStopIndex: completed ? idx : nextIdx,\r\n        insideCount: 0,\r\n      });\r\n      state = {\r\n        ...state,\r\n        phase: completed ? \"COMPLETED\" : \"ENROUTE\",\r\n        departedAt: p.deviceTs,\r\n        currentStopIndex: completed ? idx : nextIdx,\r\n        insideCount: 0,\r\n        version: state.version + 1,\r\n      };\r\n\r\n      await publishEvent(\"driver.departed.stop\", {\r\n        eventId: p.eventId, driverId: p.driverId, routeId: state.routeId, stopId: stop.id, stopIndex: idx, occurredAt: p.deviceTs\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n// ---------- lambda entry\r\nexport const handler = async (event: SQSEvent) => {\r\n  for (const rec of event.Records) {\r\n    try {\r\n      const msg = JSON.parse(rec.body) as { type: \"gps\"; payload: GpsPayload; receivedAt: string };\r\n      if (msg.type === \"gps\") await handleGps(msg.payload);\r\n      else console.warn(\"Ignoring non-gps message:\", (msg as any).type);\r\n    } catch (err) {\r\n      console.error(\"Record failed\", err);\r\n      throw err; // retry \u2192 DLQ\r\n    }\r\n  }\r\n};\r\n", "\r\n// src/aws-local.ts\r\nexport function localAwsConfig() {\r\n  const isLocal = process.env.IS_LOCAL === \"true\" || process.env.IS_OFFLINE === \"true\" || process.env.LOCALSTACK === \"true\" || process.env.STAGE === \"local\";\r\n  const endpoint = process.env.AWS_ENDPOINT_URL || process.env.LOCALSTACK_URL || \"http://localhost:4566\";\r\n  return isLocal ? { endpoint, region: process.env.AWS_REGION || \"us-east-1\",\r\n    credentials: { accessKeyId: process.env.AWS_ACCESS_KEY_ID || \"test\", secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || \"test\" } } : {};\r\n}\r\n", "import type { PutEventsCommandInput } from \"@aws-sdk/client-eventbridge\";\r\nimport { localAwsConfig } from \"../aws-local\";\r\n\r\nexport type DomainEventType =\r\n  | \"gps.received\" | \"tms.updated\"\r\n  | \"driver.arrived.pickup\" | \"driver.arrived.delivery\"\r\n  | \"driver.departed.stop\";\r\n\r\ntype Publisher = (type: DomainEventType, detail: Record<string, any>, source?: string) => Promise<void>;\r\n\r\nlet publishEvent: Publisher = async () => { /* no-op for MVP */ };\r\n\r\nconst initializeEventPublisher = async () => {\r\n  if (process.env.EVENT_BUS_NAME) {\r\n    const { EventBridgeClient, PutEventsCommand } = await import(\"@aws-sdk/client-eventbridge\");\r\n    const eb = new EventBridgeClient(localAwsConfig());\r\n    const BUS = process.env.EVENT_BUS_NAME!;\r\n    publishEvent = async (type, detail, source = \"logistics.detector\") => {\r\n      const input: PutEventsCommandInput = {\r\n        Entries: [{ EventBusName: BUS, Source: source, DetailType: type, Detail: JSON.stringify(detail) }]\r\n      };\r\n      await eb.send(new PutEventsCommand(input));\r\n    };\r\n  }\r\n};\r\n\r\ninitializeEventPublisher();\r\n\r\nexport { publishEvent };\r\n"],
  "mappings": "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",
  "names": []
}
